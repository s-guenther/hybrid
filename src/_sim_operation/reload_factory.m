function reload = reload_factory(strategy, base, peak, opt)
% RELOAD_FACTORY builds a parameterized reload strategy
%
% The control strategy must be parameterized with a few constants, i.e.
% storage dimensions, and the backward integral. To reduce the number of
% inputs and to avoid overloading functions, this function generates and
% returns the concrete control strategy function.
%
% RELOAD = RELOAD_FACTORY(STRATEGY, BASE, OPT)
%
% The returned function has the form
%   ([pwr_base, pwr_peak]) = reload(pwr_in, bw_int, [enrgy_base, enrgy_peak])
% where the input parameters a usually explicit functions of time t (in
% case signal type == 'fhandle') or step i (in case signal type == 'linear'
% or 'step')
%
% See also: CONTROL_FACTORY, SYNC_FACTORY, SIM_OPERATION.

if strcmpi(strategy, 'inter')
    request = inter_request_factory(peak.power, opt);
elseif strcmpi(strategy, 'nointer')
    request = nointer_request_factory(peak.power, opt);
else
    error('HYBRID:control:invalid_input', ...
          ['The provided signal type ''%s'' is unknown, must be\n', ...
           '''fhandle'', ''step'' or ''linear'''], sigtype)
end

base_pwr_out = @(pwr, bw_int, enrgy) ...
               sat(pwr + request(pwr, bw_int, enrgy(2)), base.power);
peak_pwr_out = @(pwr, bw_int, enrgy) ...
               pwr - base_pwr_out(pwr, bw_int, enrgy);

reload = @(pwr, bw_int, enrgy) [base_pwr_out(pwr, bw_int, enrgy);
                                peak_pwr_out(pwr, bw_int, enrgy)];
end


%% LOCAL FUNCTIONS

function request_fcn = inter_request_factory(peak_pwr_cap, opt)
    grad = opt.tanh_sim;
    if grad
        request_fcn = @(pwr, peak_enrgy, bw_int) ...
                      -peak_pwr_cap.*tanh(grad*(peak_enrgy - bw_int));
    else
        request_fcn = @(pwr, peak_enrgy, bw_int) ...
                      -peak_pwr_cap.*(peak_enrgy > bw_int) + ...
                      0            .*(peak_enrgy == bw_int) + ...
                      peak_pwr_cap .*(peak_enrgy < bw_int);
    end
end

% TODO correct this function adequately to top function
function request_fcn = nointer_request_factory(peak_pwr_cap, opt)
    grad = opt.tanh_sim;
    if grad
        % request_fcn = @(pwr, peak_enrgy, bw_int) ...
        %               max(min(0, pwr), -peak_pwr_cap).* ...
        %                 tanh(grad*(peak_enrgy - bw_int)).* ...
        %                 (peak_enrgy <= bw_int) + ...
        %               min(max(0, pwr), peak_pwr_cap).* ...
        %                 tanh(grad*(peak_enrgy - bw_int)).* ...
        %                 (peak_enrgy > bw_int);
        request_fcn = @(pwr, peak_enrgy, bw_int) ...
                      -min(abs(pwr), peak_pwr_cap).* ...
                      tanh(grad*(peak_enrgy - bw_int)).* ...
                      (sign(peak_enrgy - bw_int) == sign(pwr));
    else
        % request_fcn = @(pwr, peak_enrgy, bw_int) ...
        %               max(min(0, pwr), -peak_pwr_cap).* ...
        %                 (peak_enrgy > bw_int) + ...
        %               0.* ...
        %                 (peak_enrgy == bw_int) + ...
        %               min(max(0, pwr), peak_pwr_cap).* ...
        %                 (peak_enrgy < bw_int);
        request_fcn = @(pwr, peak_enrgy, bw_int) ...
                      max(-pwr, -peak_pwr_cap).* ...
                        (peak_enrgy > bw_int & pwr > 0) + ...
                      min(-pwr, peak_pwr_cap).* ...
                        (peak_enrgy < bw_int & pwr < 0);
    end
end
