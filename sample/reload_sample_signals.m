%% Definition of various Signals

% These signals can be avaluated with
%   [base, peak] = calc_hybrid_w_reload(signal, cut)   or
%   [base, peak] = calc_hybrid_w_reload(signal, cut, inter, step, figno) 
% and
%   leafdata = hybrid_leaf(signal)
%   plot_leaf(signal, leafdata, title, figno)

% Generic Signal Definition
siggeneric.fcn = @(t) 0;
siggeneric.amplitude = 1;
siggeneric.period = 2*pi;


% Single Triangle
sig_tri = siggeneric;
sig_tri.fcn = @(t) interp1([0 1 2 3 4]*2*pi/4, ...
[0 1 0 -1 0], ...
mod(t, 2*pi), ...
'linear');


% Double Triangle
sig_dbl = siggeneric;
sig_dbl.fcn = @(t) interp1([0 1 2 3 4 5 6 7 8]*2*pi/8, ...
[0 1 0 1 0 -1 0 -1 0], ...
mod(t, 2*pi), ...
'linear');


% Triple Triangle
sig_trb = siggeneric;
sig_trb.fcn = @(t) interp1([0 1 2 3 4 5 6 7 8 9 10 11 12]*2*pi/12, ...
[0 1 0 1 0 1 0 -1 0 -1 0 -1 0], ...
mod(t, 2*pi), ...
'linear');


% Highly Distorted Triangle
sig_high = siggeneric;
sig_high.fcn = @(t) interp1([0 0.9 1 1.1 2 2.9 3 3.1 4]*2*pi/4, ...
                           [0 0.05 1 0.05 0 -0.05 -1 -0.05 0], ...
                           mod(t, 2*pi), ...
                           'linear');

                       
% Distorted Triangle
sig_dist = siggeneric;
sig_dist.fcn = @(t) interp1([0 0.5 1 1.5 2 2.5 3 3.5 4]*2*pi/4, ...
                           [0 0.2 1 0.2 0 -0.2 -1 -0.2 0], ...
                           mod(t, 2*pi), ...
                           'linear');
                    
                       
% Trapezodial Signal
sig_trapz = siggeneric;
sig_trapz.fcn = @(t) interp1([0 0.2 1 1.8 2 2.2 3 3.8 4]*2*pi/4, ...
                            [0 1 1 1 0 -1 -1 -1 0], ...
                            mod(t, 2*pi), ...
                            'linear');         
                         
                        
% Highly Distorted Triangle, Double Peaks   
sig_high_dbl = siggeneric;
sig_high_dbl.fcn = @(t) abs(sig_high.fcn(2*t)).*(t <= pi) - ...
                        abs(sig_high.fcn(2*t)).*(t > pi);
                       
        
% Sinus with Double Peaks
sig_sin_dbl = siggeneric;
sig_sin_dbl.fcn = @(t) abs(sin(2*t)).*(t <= pi) - ...
                       abs(sin(2*t)).*(t > pi);


% Sinus with 4 Peaks
sig_sin_quad = siggeneric;
sig_sin_quad.fcn = @(t) abs(sin(4*t)).*(t <= pi) - ...
                       abs(sin(4*t)).*(t > pi);         


% Tetris Signal with double Peaks
sig_tet_dbl = siggeneric;
sig_tet_dbl.fcn = @(t) (t > 0/4*pi & t <= 1/4*pi).*1 + ...
                       (t > 1/4*pi & t <= 2/4*pi).*0.5 + ...
                       (t > 2/4*pi & t <= 3/4*pi).*1 + ...
                       (t > 3/4*pi & t <= 4/4*pi).*0.5 + ...
                       (t > 4/4*pi & t <= 5/4*pi).*-0.5 + ...
                       (t > 5/4*pi & t <= 6/4*pi).*-1 + ...
                       (t > 6/4*pi & t <= 7/4*pi).*-0.5 + ...
                       (t > 7/4*pi & t <= 8/4*pi).*-1;


% Triangle Signal with negative part in loading phase
sig_neg = siggeneric;
sig_neg.fcn = @(t) interp1([0 1 2 3 4 5 6 7 8]*2*pi/8, ...
                           [0 1 -1 1 0 -1 1 -1 0], ...
                           mod(t, 2*pi), ...
                           'linear');   


% Triangle Signal with less negative Part in loading Phase
sig_neg_half = siggeneric;
sig_neg_half.fcn = @(t) interp1([0 1 2 3 4 5 6 7 8]*2*pi/8, ...
                                [0 1 -0.5 1 0 -1 0.5 -1 0], ...
                                mod(t, 2*pi), ...
                                'linear');   
                            
% Triangle Signal with more negative part in loading phase
sig_neg_quart = siggeneric;
sig_neg_quart.fcn = @(t) interp1([0 1 2 3 4 5 6 7 8]*2*pi/8, ...
                                [0 1 -0.75 1 0 -1 0.75 -1 0], ...
                                mod(t, 2*pi), ...
                                'linear');                             
